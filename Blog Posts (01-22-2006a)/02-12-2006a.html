<link href="style.css" rel="stylesheet" type="text/css" />
<p align="justify"><strong>Yet another method for protecting your JavaScript based Intellectual Property - SDA's </strong></p>
<p align="justify">SDA stands for Self Decrypting Archive - SDA's are constructed to allow insecure information to be delivered in a secure manner with or without the use of SSL. </p>
<p align="justify">SSL only protects the information between the server and the client but SSL does nothing to protect the information once it has been received by the browser.</p>
<p align="justify">The goal of Intellectual Property Protection in relation to JavaScript is to ensure the JavaScript content is NOT viewable by those who wish to view the content using a browser. This goal may seem counter-intuitive but this is &quot;THE&quot; goal.  Any other goal would render the JavaScript content too easily viewable and therefore useless.</p>
<p align="justify"><strong>JavaScript Obfuscation is NOT enough !</strong>  </p>
<p align="justify">It is not enough to simply obfuscate the JavaScript however obfuscation is a good place to begin. When obfuscation is correctly done it renders the JavaScript largely useless but those who may wish to understand what the code does however the code may still be able to be reused. The goal of obfuscation is to cause those who wish to use the obfuscated code to have to waste too much time working with the code AND to cause the code to become unreadable but &quot;unreadable&quot; is a word that is miused - the correct word is &quot;unintelligible&quot; which has the same conceptual root as &quot;unreadable&quot; but it goes a bit beyond simply not being able to read the information with one's eyes. The word &quot;unintelligible&quot; conveys the fact that the information can be &quot;read&quot; however one cannot understand what is being &quot;read&quot;. Perhaps people tend to use the wrong word in this case because they prefer not to feel as though they are &quot;stupid&quot; because the word &quot;unintelligible&quot; may convey some sense of the reader being less <em>intelligent</em> than may be desired. </p>
<p align="justify">The first step is therefore &quot;obfuscation&quot; that makes every local variable reference into as short as possible meaningless reference. Human beings tend to write code using longer variable names for things that carry conceptual meaning(s). Part of the conceptual meaning of the code lies within the names that are used for local variables, for instance. Function names also carry meaning so local or private function names must also be <em>obfuscated</em>. Whitespace also carries meaning so whitespace must be removed. Layout also carries meaning - <em>layout</em> would be indentation between lines of code so code layout must be removed. </p>
<p align="justify">Properly obfuscated code would appear to be meaningless lumps of JavaScript devoid of obvious notations of meaning.</p>
<p align="justify"><strong>SDA's can be very simple or far more complex</strong>  </p>
<p align="justify">SDA's can use simplistic forms of encryption or more complex forms such as BlowFish or MD5.</p>
<p align="justify">Decryption keys should also be hidden to make it difficult for a casual observer to determine the actual key to be used. A simple way to hide a key in plain sight woud be to bury it within a lump of meaningless data. Take for instance an MD5 key which would be 128 bits in length but when buried within a lump of seemingly ramdom bits, say 1 million seemingly random bits, if properly done a causal observer could intercept those 1 million seemingly random bits and still not be able to retrieve the correct 128 bits that form the proper MD5 key. One additional step of encoding the checksum for the block of 1 million bits would help to make the whole block that contains the MD5 key self-validating and somewhat tamper-proof. Spreading the 128 bit MD5 key and the checksum throughout the block of 1 million random bits would also help to hide the original MD5 key in plain sight. Someone who had successfully intercepted the block of 1 million bits would have to know the method used to hide the 128 bit MD5 key and the checksum in order to be able to use the MD5 key. When one uses this technique of hiding a key in plain-sight one might also use this technique in reverse so that a client would have to create a self-validating block of 1 million bits witha properly encoded MD5 key and checksum so that the server could obtain the proper response from the client but this only makes sense otherwise the whole system might become useless.</p>
<p align="justify">Obviously all the JavaScript a hacker would need once the JavaScript was obtained assuming the JavaScript was self-decrypted and the code was made useful even though it was obfuscated would have to be visible to the browser and therefore visible to a hacker who was sufficiently skilled. What more could be done to thwart the hacker's attempts at breaking this rather simple system ? </p>
<p align="justify">Well if one were to create a series of fake JavaScript routines that decoded a block of seemingly random bits back into the original MD5 key which could then be decoded using MD5 to reveal the message from the server that asked the client to create a specific response which would then need to be encoded using the same technique the server used when asking the client for the response - well suddenly the whole process just became a bit more complex now didn't it ?</p>
<p align="justify">So only one out of say a hundred routines would be used to decode and encode the required block of 1 million bits of seemingly random data. But what happens when several of these hundred routines are used together for form a combination then a would-be hacker would have to dig through all that JavaScript once recovered to determine just what routines out of all that background noise was being used to achieve the deisred goals. Suddenly a would-be hacker would have to waste an awful lot of time trying to break a system that would be better left alone.</p>
<p align="justify"><strong>The only barriers to creating this type of system would be processing power.</strong>  </p>
<p align="justify">But what it a simple benchmark routine were constructed to determine how much processing power a client browser had to allow the server to tailor the JavaScript being fed to the browser to allow the browser that has more processing power to use greater levels of encryption. This would mean a would-be hacker who would typically want to have the fastest computer on the planet would also have to waste more time than someone who used a slower computer because slower means less work can be done by the browser and therefore less means easier to crack.</p>
<p align="justify"><strong>Temporal based &quot;adaptive&quot; encryption techniques might also be useful</strong> </p>
<p align="justify">Rather than havng only a single encryption technique it would be more useful to employ several and then spread them out over a temporal domain such as if one had 6 techniques each one used for only 10 minutes. This would allow the code that decodes to be aware of the time of day and to employ the proper technique when that technique was being used. Obviously the server would have to know the <em>temporal bias</em> that existed between the client and the server but this could be easily determined using JavaScript since the client knows what time it thinks it is and it only needs to relay the current time from the client's perspective to the server upon request. This also opens the door to being able to use time as a way to authenticate the client since the client would be required to respond to the server in a short period of time - if the client send the next AJAX payload too late the server can simply hang-up on the client and refuse to communicate for some inconveniently long time such as say 180 minutes or the like. Under normal circumstances, when no hackers are trying to break the system the client would simply respond fast enough based on the benchmark data and the temporal signatures being used and the server would not hang-up on the client until the user chose to cease using the system.</p>
<p align="justify">It is left up to those who read this blog to make use of these techniques or simply wait for <strong>RABID_AJAX&#8482;</strong> to become a product you can buy a license to use because   <strong>RABID_AJAX&#8482;</strong> is being coded right now to use these techniques and more. </p>
<p align="justify"><strong>We here at Rabid Central are working on getting our new 64 Bit DB Server Online <u>very</u> soon... </strong> </p>
<p align="justify">Picture this, a 64-bit Dual Core  X2 4200+ with 4 GB RAM and 1000 GB Disk Space running 64-bit Windows 2003 R2 and 64-bit SQL Server 2005.</p>
<p align="justify">The 4 GB RAM have been purchased along with the 1000 GB of hard drives and we are now simply working on getting these items installed in the computer case so we can burn them in over the next several weeks. </p>
<p align="justify">This Db Server will quite literally scream and it will allow our site(s) to be very very fast.</p>
<p align="justify"><strong>We here at Rabid Central are working on getting our new FX-60 Workstation Online soon... </strong> </p>
<p align="justify">Every time we deploy a new front-line production server we have to buy a new workstation to replace the workstation that was promoted from back-office use to front-line use and this time we have set our sights on a top of the line SLI based FX-60 system.</p>
<p align="justify"><strong>FX-60 Dual Core CPU with 4 GB RAM, 2 ea. GTX 7800 Nvidia video cards with 2 ea 74 GB Raptor SATA Drives</strong> and this little gem will quite literally scream ! </p>
<p align="justify">Stay tuned. We have been gathering price quotes and will be making a purchase soon. </p>
<p align="justify"><strong>Development of RABID_AJAX&#8482; proceeds... </strong></p>
<p align="justify">We have been working hard on <strong>RABID_AJAX&#8482;</strong> cooking up new and interesting ways to obscure and hide JavaScript content from those who may wish to see how we are doing things.</p>
<p align="justify">Keep in mind the fact that when <strong>RABID_AJAX&#8482;</strong> is finally ready as a product YOU can download and use it will provide YOU too with the means to keep your valuable JavaScript content safe and secure from those who might with to steal your ideas from you.</p>
<p align="justify">We here at Rabid Central take Intellectual Property Protection very seriously, very seriously indeed. </p>
<p align="justify"><strong>Yes, we are going to change the way JavaScript is delivered to YOUR browser in ways that will forever change the face of the Internet.</strong> </p>
<p align="justify">Mankind will once again be free to develop JavaScript without the fear that unethical people will be able to simply copy their codes or reverse-engineer their codes. You see, some of us spend a lot of time developing our JavaScript and we simply do not wish to just give that code away to all those who wish to see it. </p>
<p align="justify">It does not matter to us, the producers of <strong>RABID_AJAX&#8482;</strong>, that nobody else in the world might wish to use our techniques and it does not matter if we make any money doing this or not. It is enough that WE will be free to code and deliver our JavaScript based AJAX powered applications without having to just give our codes away for all to use and abuse without our permisson. </p>
